import type { IntegrationContext } from './types'
import * as prettier from 'prettier'

function formatUnionStringType(list: (string | number)[]) {
	return list.length > 0 ? list.map(i => typeof i === 'number' ? i : `'${i}'`).join(' | ') : 'never'
}

async function generateOverloadContent(ctx: IntegrationContext) {
	const paramsLines: string[] = []
	const fnsLines: string[] = []
	const usages = [...ctx.usages.values()].flat()

	for (let i = 0; i < usages.length; i++) {
		const usage = usages[i]!
		paramsLines.push(
			...usage.params.map((param, index) => `type P${i}_${index} = ${JSON.stringify(param)}`),
		)
		fnsLines.push(
			'  /**',
			'   * ### StyoCSS Preview',
			'   * ```css',
			// CSS Lines
			...(await prettier.format(await ctx.engine.renderPreviewStyles(...usage.params), { parser: 'css' }))
				.split('\n')
				.map(line => `   * ‎${line.replace(/^(\s*)/, '$1‎')}`),
			'   * ```',
			'   */',
			`  fn(...params: [${usage.params.map((_, index) => `p${index}: P${i}_${index}`).join(', ')}]): ReturnType<StyleFn>`,
		)
	}

	return [
		'interface PreviewOverloads<StyleFn extends (StyleFn_Array | StyleFn_String | StyleFn_Inline)> {',
		...fnsLines,
		'  /**',
		'   * StyoCSS Preview',
		'   * Save the current file to see the preview.',
		'   */',
		`  fn(...params: Parameters<StyleFn>): ReturnType<StyleFn>`,
		'}',
		...paramsLines,
	]
}

function generateGlobalDeclaration(ctx: IntegrationContext) {
	const { fnName } = ctx
	return [
		'declare global {',
		'  /**',
		'   * StyoCSS',
		'   */',
		`  const ${fnName}: Styo`,
		'',
		'  /**',
		'   * StyoCSS Preview',
		'   */',
		`  const ${fnName}p: StyoWithPreview`,
		'}',
		'',
	]
}

function generateVueDeclaration(ctx: IntegrationContext) {
	const { hasVue, fnName } = ctx

	if (!hasVue)
		return []

	return [
		'declare module \'vue\' {',
		'  interface ComponentCustomProperties {',
		'    /**',
		'     * StyoCSS',
		'     */',
		`    ${fnName}: Styo`,
		'',
		'    /**',
		'     * StyoCSS Preview',
		'     */',
		`    ${fnName}p: StyoWithPreview`,
		'  }',
		'}',
		'',
	]
}

export async function generateDtsContent(ctx: IntegrationContext) {
	const {
		engine,
		transformedFormat,
	} = ctx

	const lines = []
	const autocomplete = engine.config.autocomplete
	lines.push(
		`// Auto-generated by ${ctx.currentPackageName}`,
		`import type { StyleFn } from \'${ctx.currentPackageName}\'`,
		'',
		'interface _Autocomplete {',
		`  Selector: ${formatUnionStringType([...autocomplete.selectors])}`,
		`  StyleItemString: ${formatUnionStringType([...autocomplete.styleItemStrings])}`,
		`  ExtraProperty: ${formatUnionStringType([...autocomplete.extraProperties])}`,
		`  ExtraCssProperty: ${formatUnionStringType([...autocomplete.extraCssProperties])}`,
		`  PropertiesValue: { ${Array.from(autocomplete.properties.entries(), ([k, v]) => `'${k}': ${v.join(' | ')}`).join(',')} }`,
		`  CssPropertiesValue: { ${Array.from(autocomplete.cssProperties.entries(), ([k, v]) => `'${k}': ${formatUnionStringType(v)}`).join(',')} }`,
		'}',
		'',
		'type _StyleFn = StyleFn<_Autocomplete>',
		'',
	)

	if (transformedFormat === 'array') {
		lines.push(
			'type StyleFn_Normal = StyleFn_Array',
		)
	}
	else if (transformedFormat === 'string') {
		lines.push(
			'type StyleFn_Normal = StyleFn_String',
		)
	}
	else if (transformedFormat === 'inline') {
		lines.push(
			'type StyleFn_Normal = StyleFn_Inline',
		)
	}
	lines.push(
		'type StyleFn_Array = (...params: Parameters<_StyleFn>) => string[]',
		'type StyleFn_String = (...params: Parameters<_StyleFn>) => string',
		'type StyleFn_Inline = (...params: Parameters<_StyleFn>) => void',
		'',
		'type Styo = StyleFn_Normal & {',
		'  str: StyleFn_String',
		'  arr: StyleFn_Array',
		'  inl: StyleFn_Inline',
		'}',
		`type StyoWithPreview = PreviewOverloads<StyleFn_Normal>[\'fn\'] & {`,
		`  str: PreviewOverloads<StyleFn_String>[\'fn\']`,
		`  arr: PreviewOverloads<StyleFn_Array>[\'fn\']`,
		`  inl: PreviewOverloads<StyleFn_Inline>[\'fn\']`,
		'}',
		'',
	)

	lines.push(...generateGlobalDeclaration(ctx))
	lines.push(...generateVueDeclaration(ctx))

	lines.push(...await generateOverloadContent(ctx))

	return lines.join('\n')
}
